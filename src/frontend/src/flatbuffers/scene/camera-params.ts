// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



export class CameraParams implements flatbuffers.IUnpackableObject<CameraParamsT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):CameraParams {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsCameraParams(bb:flatbuffers.ByteBuffer, obj?:CameraParams):CameraParams {
  return (obj || new CameraParams()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsCameraParams(bb:flatbuffers.ByteBuffer, obj?:CameraParams):CameraParams {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new CameraParams()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

position(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

positionLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

positionArray():Float32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Float32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

lookAt(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

lookAtLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

lookAtArray():Float32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Float32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

up(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

upLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

upArray():Float32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Float32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

fov():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 60.0;
}

near():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.1;
}

far():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 1000.0;
}

forceCamera():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

static startCameraParams(builder:flatbuffers.Builder) {
  builder.startObject(7);
}

static addPosition(builder:flatbuffers.Builder, positionOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, positionOffset, 0);
}

static createPositionVector(builder:flatbuffers.Builder, data:number[]|Float32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createPositionVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createPositionVector(builder:flatbuffers.Builder, data:number[]|Float32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]!);
  }
  return builder.endVector();
}

static startPositionVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addLookAt(builder:flatbuffers.Builder, lookAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, lookAtOffset, 0);
}

static createLookAtVector(builder:flatbuffers.Builder, data:number[]|Float32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createLookAtVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createLookAtVector(builder:flatbuffers.Builder, data:number[]|Float32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]!);
  }
  return builder.endVector();
}

static startLookAtVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addUp(builder:flatbuffers.Builder, upOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, upOffset, 0);
}

static createUpVector(builder:flatbuffers.Builder, data:number[]|Float32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createUpVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createUpVector(builder:flatbuffers.Builder, data:number[]|Float32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]!);
  }
  return builder.endVector();
}

static startUpVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addFov(builder:flatbuffers.Builder, fov:number) {
  builder.addFieldFloat32(3, fov, 60.0);
}

static addNear(builder:flatbuffers.Builder, near:number) {
  builder.addFieldFloat32(4, near, 0.1);
}

static addFar(builder:flatbuffers.Builder, far:number) {
  builder.addFieldFloat32(5, far, 1000.0);
}

static addForceCamera(builder:flatbuffers.Builder, forceCamera:boolean) {
  builder.addFieldInt8(6, +forceCamera, +false);
}

static endCameraParams(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createCameraParams(builder:flatbuffers.Builder, positionOffset:flatbuffers.Offset, lookAtOffset:flatbuffers.Offset, upOffset:flatbuffers.Offset, fov:number, near:number, far:number, forceCamera:boolean):flatbuffers.Offset {
  CameraParams.startCameraParams(builder);
  CameraParams.addPosition(builder, positionOffset);
  CameraParams.addLookAt(builder, lookAtOffset);
  CameraParams.addUp(builder, upOffset);
  CameraParams.addFov(builder, fov);
  CameraParams.addNear(builder, near);
  CameraParams.addFar(builder, far);
  CameraParams.addForceCamera(builder, forceCamera);
  return CameraParams.endCameraParams(builder);
}

unpack(): CameraParamsT {
  return new CameraParamsT(
    this.bb!.createScalarList<number>(this.position.bind(this), this.positionLength()),
    this.bb!.createScalarList<number>(this.lookAt.bind(this), this.lookAtLength()),
    this.bb!.createScalarList<number>(this.up.bind(this), this.upLength()),
    this.fov(),
    this.near(),
    this.far(),
    this.forceCamera()
  );
}


unpackTo(_o: CameraParamsT): void {
  _o.position = this.bb!.createScalarList<number>(this.position.bind(this), this.positionLength());
  _o.lookAt = this.bb!.createScalarList<number>(this.lookAt.bind(this), this.lookAtLength());
  _o.up = this.bb!.createScalarList<number>(this.up.bind(this), this.upLength());
  _o.fov = this.fov();
  _o.near = this.near();
  _o.far = this.far();
  _o.forceCamera = this.forceCamera();
}
}

export class CameraParamsT implements flatbuffers.IGeneratedObject {
constructor(
  public position: (number)[] = [],
  public lookAt: (number)[] = [],
  public up: (number)[] = [],
  public fov: number = 60.0,
  public near: number = 0.1,
  public far: number = 1000.0,
  public forceCamera: boolean = false
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const position = CameraParams.createPositionVector(builder, this.position);
  const lookAt = CameraParams.createLookAtVector(builder, this.lookAt);
  const up = CameraParams.createUpVector(builder, this.up);

  return CameraParams.createCameraParams(builder,
    position,
    lookAt,
    up,
    this.fov,
    this.near,
    this.far,
    this.forceCamera
  );
}
}
